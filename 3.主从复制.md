# 主从复制


Redis中，可以通过在客户端执行`SLAVEOF`命令或通过在redis.conf上配置`slaveof`设置来A服务器复制B服务器

```
127.0.0.1 7000> SLAVEOF 127.0.0.1 6379 
```

以上命令代表在端口7000的Redis上复制端口6379的Redis服务器，其中被复制的服务器称为主服务器（6379端口），主动复制的服务器称为从服务器（7000端口）。

## Redis2.8版本之前的复制操作

在**Redis2.8**版本以前，Redis进行主从复制的步骤主要是以下两步：

* 同步操作：将从服务器的状态同步成跟主服务器一致；

  当客户端执行SLAVEOF命令时，服务器首先会执行同步操作，同步操作通过执行SYNC命令来完成

  > 1. 从服务器向主服务器发送SYNC命令
  > 2. 主服务器接收到SYNC命令，执行BGSAVE操作，生成一个RDB文件，并使用一个缓冲区记录从现在开始后面执行的所有写命令
  > 3. 当主服务器执行完BGSAVE操作后，将生成的RDB文件发送给从服务器，从服务器接收并载入RDB文件，将从服务器状态同步成跟主服务器一致
  > 4. 主服务器将执行BGSAVE后缓冲区记录的所有写命令同步给从服务器，从服务器接收并执行这些写命令，将自己的数据库状态更新至主服务器数据库所处的状态

  ![image-20180625172944315](https://ws2.sinaimg.cn/large/006tKfTcgy1fsnjzx1h83j31kw0970u0.jpg)

* 命令传播：当同步操作后主从服务器状态一致后，主服务器执行相应的写操作导致状态跟从服务器又不一致时，主服务器会将每次执行的命令传递给从服务器，重新将服务器状态修改成一致；

通过`同步操作`跟`命令传播`虽然可以实现主从复制，但是也是存在缺陷的。当主从服务器处于一致状态后，如果这个时候从服务器宕机了，等从服务器恢复时，从服务器会发现跟主服务器的状态不一致，那么会重新发一次SYNC命令，主服务器会从头重新开始一次`同步操作`；这样的操作是比较低效且耗费资源的；

> 每次执行SYNC操作，服务器会执行以下动作：
>
> 1. 主服务器执行BGSAVE操作生成RDB文件，会消耗主服务器大量CPU、内存和磁盘的I/O资源；
> 2. 主服务器需要将RDB文件发送给从服务器，会消耗网络资源（带宽和流量），并对主服务器响应命令请求时间产生影响；
> 3. 从服务器需要接收并加载主服务器发来的RDB文件，期间会阻塞无法响应请求；

## Redis2.8版本之后的复制操作

为了优化服务器宕机后的同步操作，Redis在2.8版本之后采用了**`PSYNC`**来替换**`SYNC`**操作，PSYNC分为两种情况进行同步操作：

* 完整重同步：跟Redis2.8版本之前的同步操作阶段做的一样的工作

* 部分重同步：主要用于从服务器与主服务器断开连接之后的复制操作，由以下三个部分组成：

  * 主服务器的复制偏移量和从服务器的复制偏移量
  * 主服务器的复制积压缓冲区
  * 服务器的运行ID

### 复制偏移量

在进行复制操作时，主从服务器分别会维护好自身的复制偏移量`offset`

* 当主服务器往从服务器传播N个字节的数据时，将会把自己的复制偏移量+N；
* 当从服务器从主服务器接收N个字节的数据时，也会将自己的复制偏移量+N；

通过对主从服务器的复制偏移量进行比较，就可以知道主从服务器是否处于状态一致；如果短线重连后从服务器发现自己的状态跟主服务器不一致，那么会向主服务器发送一个新的`PSYNC`命令；

### 复制积压缓冲区

主服务器在接收到`PSYNC`命令后，需要根据复制积压缓冲区来判断是要进行`完整重同步`还是进行`部分重同步`；复制积压缓冲区维护的是一个FIFO的固定大小的队列，默认大小为1MB；

> 固定大小的FIFO队列，当新插入的数据队列无法容纳的时候，会把最旧的那条数据出列；
> 

主服务器在进行`命令传播`的时候，除了会把命令发给从服务器，也会把命令发给复制积压缓冲区进行记录，缓冲区除了记录命令还会为队列中的每个字节记录相应的复制偏移量`offset`。从服务器在向主服务器发送PSYNC命令的时候，会把从服务器的offset也发送给主服务器，主服务器可以根据接收到的offset跟缓冲区记录的offset，判断要进行何种同步操作。

* 执行部分重同步：如果复制积压缓冲区中的队列还存放着从服务器断开后的命令（即从服务器offset+1），那么主服务器会往从服务器回复一个`+CONTINUE`回复，并将相应的Redis写命令传播给从服务器；
* 执行完整重同步：如果复制积压缓冲区中的队列已经不再存放从服务器断开后的命令了，那么主服务器将会向从服务器回复一个`+FULLRESYNC <runid> <offset>`回复，并通过完整重同步来重新同步；

> 复制积压缓冲区的默认大小为1MB，可以通过修改配置文件中的`repl-backlog-size`选项进行修改，具体的数值可以通过：second * write_size_per_second来估算，推荐设置为2 * second * write_size_per_second
>
> second：从服务器断开主服务器后重新连上所需的平均时间，单位秒
>
> write_size_per_second：主服务器平均每秒产生的写命令数据量（协议命令的写命令的长度总和）

### 主服务器运行ID

主从服务器都会有自己的运行ID，为一个长度为40个随机数的十六进制字符组成。当主服务器初次对从服务器进行同步的时候，主服务器会将自己的运行ID同步给从服务器，从服务器会记录起来；而当从服务器断开再重新连接上主服务器的时候，会把之前保存的主服务器ID也传递给主服务器，主服务器会把接收到的运行ID跟自己的运行ID进行比较才能确定是否执行部分重同步

* 如果主服务器的运行ID跟从服务器的运行ID一致，那么就可以执行部分重同步（结合复制积压缓冲区）
* 如果不一致，那么代表在跟主服务器断开期间，之前复制的主服务器已经不是现在这个主服务器了，那么需要重新进行完整重同步操作；

![image-20180625182718004](https://ws3.sinaimg.cn/large/006tKfTcgy1fsnlntzv25j31iy0tkdl6.jpg)

## 复制的具体实现

* 设置服务器地址及端口

  当客户端向服务器发送`SLAVEOF 127.0.0.1 6379`命令时，从服务器会在自己的redisServer结构中保存主服务器的ip及端口号，之后再向客户端返回`OK`命令回复；

  ```
  struct redisServer{
      // 主服务器的地址
      char *masterhost;
      // 主服务器的端口
      int masterport;
  };
  ```

* 建立套接字连接

  从服务器根据命令设置的IP跟端口，创建连向主服务器的套接字连接。如果创建的套接字成功连接(connect)到主服务器，那么从服务器将为这个套接字关联一个专门用于复制工作的文件事件处理器。这个处理器将复制执行后续的复制工作，如接收RDB文件，接收主服务器传播来的写命令；

  而主服务器在接受(accept)从服务器的套接字之后，将为该套接字创建相应的客户端状态，并将从服务器当作连接主服务器的一个客户端来对待，这时**从服务器既是服务端也是客户端（向主服务器发送命令请求）**；

* 发送PING命令

  从服务器在成为主服务器的客户端后，会立即向服务器发送一个`PING`命令，主要作用是

  1. 虽然主从服务器已经建立了套接字连接，但是还未通信，通过发送`PING`命令可以检查套接字的读写状态是否正常
  2. 复制工作接下的几个步骤都是必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送`PING`命令可以检查主服务器能否正确处理命令请求；

  主服务器在接收到`PING`命令后，可能存在以下处理情况：

  * 如果主服务器向从服务器返回了一个回复命令，但是从服务器不能在规定的时限内取出命令回复，那么主从服务器之间的网络连接状态不正常，需要断开重新建立连向主服务器的套接字；
  * 如果主服务器向从服务器返回了一个错误回复，表示主服务器暂时无法处理从服务器的命令请求，无法进行后续的复制操作，同样需要断开重新建立连向主服务器的套接字；
  * 如果主服务器向从服务器返回一个`PONG`回复，那么代表主从服务器连接正常，可以正常处理命令请求，从服务器可以继续执行复制工作；

* 身份验证

  从服务器在接收到主服务器的`PONG`命令回复后，紧接着需要进行身份验证。

  * 如果从服务器配置了masterauth选项，那么要进行身份验证
  * 如果从服务器没有配置masterauth选项，那么不需要进行身份验证

  > 通过masterauth passwd来设置主服务器的密码

  在进行验证阶段，从服务器会发送一个`AUTH passwd`操作来进行身份验证，验证过程可能存在以下情况

  * 如果主服务器没有设置`requirepass`选项，且从服务器也没有设置`masterauth`选项，那么验证通过
  * 如果主从服务器设置的密码一致，那么验证通过，如果不一致，主服务器会返回一个`invalid password`错误
  * 如果主服务器设置了`requirepass`但是从服务器没有设置`masterauth`，那么主服务器会返回一个`NOAUTH`错误；相反如果主服务器没有设置`requirepass`，但是从服务器设置了`masterauth`，那么主服务器会返回一个`no password is set`错误；

  ![image-20180625191258022](https://ws3.sinaimg.cn/large/006tKfTcgy1fsnmzvjo95j31kw0wzq8d.jpg)
  > 所有的验证错误都需要重新建立套接字连接

* 发送端口信息

  在验证身份通过后，从服务器会向主服务器发送`REPLCONF listening-port <port-number>`命令，向主服务器发送从服务器的监听端口号。

  > 如果从服务器的端口号为7000，那么发送命令为：REPLCONF listening-port  7000

  主服务器在接收到这个端口号后，会将端口号记录到从服务器所对应的客户端状态的slave_listening_port属性中，该记录目前就是在主服务器执行`INFO replication`命令时打印从服务器端口号用。

  ```
  typedef struct redisClient{
      // 从服务器的监听端口号
      int slave_listening_port;
  } redisClient;
  ```

* 同步

  从服务器向主服务器发送`PSYNC`命令，执行同步操作，并将自己的数据库状态同步成跟主服务器数据库状态一致。在执行同步操作之前，只有从服务器是主服务器的客户端，但是在同步操作之后，主服务器也会成为从服务器的客户端

  * 完整重同步：主服务器要将缓冲区里面的写命令发送给从服务器，所以需要作为从服务器的客户端
  * 部分重同步：主服务器需要将复制积压缓冲区的写命令发送给从服务器，也需要作为从服务器客户端
  ![image-20180625194918429](https://ws2.sinaimg.cn/large/006tKfTcgy1fsno143tbjj31kw07sq4y.jpg)
  > 主服务器成为从服务器的客户端，也是命令传播的基础

* 命令传播

  完成同步动作后，主服务器会进行命令传播，一直将自己执行的写命令发送给从服务器，从服务器一直接收并执行相应的写命令，保证主从服务器保持一致；

## 心跳检测

主从服务器需要通过心跳连接来检测连接是否正常，从服务器会**每隔一秒**向主服务器发送`RELICONF ACK <replication_offset>`命令；其中`replication_offset`为从服务器的当前复制偏移量。发送该命令有三个作用

* 检测主从服务器的网络连接状态

  检测主从连接是否正常，如果主服务器超过一秒钟没有收到从服务器的`REPLCONF ACK`命令，就认为连接出了问题；通过主服务器的`INFO replication`命令可以查看从服务器最后一次往主服务次发送命令的时间；

* 辅助实现min-slaves的实现

  Redis可以通过`min-slaves-to-write`和`min-slaves-max-lag`来防止主服务器在不安全的情况下执行写命令。

  * min-slaves-to-write：从服务器数量低于该值时，主服务器将拒绝执行写命令
  * min-slaves-max-lag：N个从服务器的延迟(lag)都大于等于该值(单位秒)时，主服务器将拒绝执行写命令

* 检查命令丢失

  如果出现网络故障，主服务器传播给从服务器的写命令在半路丢失了，那么当从服务器向主服务器发送`REPLCONF ACK`命令时，主服务器会发现从服务器的复制偏移量少于自己的复制偏移量，那么主服务器会根据从服务器提交的复制偏移量，在复制积压缓冲区里找到从服务器缺少的数据，将相应的命令发送给从服务器；