# 对象与数据结构

## 对象

Redis中存在着五种数据对象：数据库对象`REDIS_STRING`、列表对象`REDIS_LIST`、哈希对象`REDIS_HASH`、集合对象`REDIS_SET`、有序集合对象`REDIS_ZSET`。



Reids用`redisObject`结构来表示数据库中的每一个对象。该结构中用以下三个属性来保存数据的信息；

-  type属性：用于记录该对象的类型；
- encoding属性：用于记录对象对应的编码；
- ptr属性：数据指针，指向底层实现数据结构的指针；



### type属性

type属性用于记录对象的类型，以下表格对应着上述五种不同数据对象对应的数据类型；

| 数据类型     | 对象名称     |
| ------------ | ------------ |
| REDIS_STRING | 字符串对象   |
| REDIS_LIST   | 列表对象     |
| REDIS_HASH   | 哈希对象     |
| REDIS_SET    | 集合对象     |
| REDIS_ZSET   | 有序集合对象 |



### encoding属性



encoding记录对象所使用的编码，准确的说，可以说是对象所使用的底层数据结构，各个不同对象对应的编码如下

| 数据类型       | 编码常量                     | 编码所对应的底层数据结构                                     |
| -------------- | ---------------------------- | ------------------------------------------------------------ |
| REDIS_STRING   | REDIS_ENCODING_INT           | long类型对应的整数                                           |
| REDIS_STRING   | REDIS_ENCODING_EMBSTR        | 使用embstr编码的简单动态字符串实现的字符串对象               |
| REDIS_STRING   | REDIS_ENCODING_RAW           | 使用简单动态字符串实现的字符串对象                           |
| REDIS_LIST     | REDIS_ENCODING_ZIPLIST       | 使用压缩列表实现的列表对象                                   |
| REDIS_LIST     | REDIS_ENCODING_LINKEDLIST    | 使用双端列表实现的列表对象                                   |
| **REDIS_LIST** | **REDIS_ENCODING_QUICKLIST** | **使用快速列表（压缩列表及双端列表）实现的列表对象（新版本）** |
| REDIS_HASH     | REDIS_ENCODING_HT            | 使用字典实现的哈希对象                                       |
| REDIS_HASH     | REDIS_ENCODING_ZIPLIST       | 使用压缩列表实现的哈希对象                                   |
| REDIS_SET      | REDIS_ENCODING_INTSET        | 使用整数集合实现的集合对象                                   |
| REDIS_SET      | REDIS_ENCODING_HT            | 使用字典实现的集合对象                                       |
| REDIS_ZSET     | REDIS_ENCODING_ZIPLIST       | 使用压缩列表实现的有序集合对象                               |
| REDIS_ZSET     | REDIS_ENCODING_SKIPLIST      | 使用跳跃表和字典实现的有序集合对象                           |



>  使用encoding来为对象指定不同的底层实现，有助于提升Redis的灵活性及效率；



## 数据结构

根据以上的表格划分，我们来看看不同数据对象中对应的数据结构的相关结构说明；

### 简单动态字符串对象

对于字符串的存储，Redis没有直接使用C语言传统的字符串来表示（以空符号结尾的字符数组），而是采用了自己构建的一种新的SDS（simple dynamic string简单动态字符串对象）抽象对象；

我们知道Redis 是一种K-V的键值对存储的NOSQL数据库，而Redis的所有Key（数据库键）都适用SDS对象来实现的，而包含字符串的键值也是用SDS存储的；

#### SDS跟C字符串的异同点

SDS对象中，用以下属性记录者字符串对象的相关信息：

* len属性：记录SDS对象所保存的字符串的长度
* free属性：记录SDS对象中未使用字节的长度
* buf属性：保存的是一个char类型的数组，用于记录实际的字符串信息

SDS遵循C字符串中用`\0`空字符串结尾的惯例，保存空字符串的1个字节不记录在len属性之中，而是由SDS自动额外的分配1字节空间，并添加到字符串末尾中；这样SDS可以继续保留C字符串函数库中的一些函数；

**关于SDS跟C字符串的异同点，可以通过以下表格来进行说明**

| C字符串                                  | SDS                                              |
| ---------------------------------------- | ------------------------------------------------ |
| 获取字符串长度的时间复杂度为O(N)         | 获取字符串长度的时间复杂度为O(1)                 |
| API是不安全的，可能造成缓冲区溢出        | API是安全的，不会造成缓冲区溢出                  |
| 修改N次字符串长度，需要进行N次内存重分配 | 修改N次字符串长度，**最多**需要进行N次内存重分配 |
| 只能保存文本数据，无法保存二进制数据     | 可以保存文本及二进制数据                         |
| 可以使用所有<string.h>的函数             | 可以使用部分<string.h>函数                       |



1、SDS对象存在了以上属性之后，想获取一个字符串的长度的时候，就不需要像C字符串一样遍历整个字符串了，所以**SDS获取一个字符串长度的时候，时间复杂度为O(1)，只需要获取len的属性值返回即可，而C字符串需要O(N)的时间复杂度；**

2、C字符串因为不记录自己本身的数据长度，所以是不安全的，容易造成**缓冲区溢出**。

​	缓冲区溢出：假设内存中紧邻着两个C字符串s1、s2；其中s1保存着“Redis”，s2保存着“MongoDB”，这个时候如果我们把s1进行了拼接，加上了“ Cluster”，但是却忘记了为s1分配足够的空间，那么s1就会溢出到s2的空间中，导致s2保存的内容被修改；具体体现如下图：

![image-20180619102642737](https://ws1.sinaimg.cn/large/006tNc79gy1fsga1xmpm2j31aq04ugme.jpg)



![image-20180619102708389](https://ws4.sinaimg.cn/large/006tNc79gy1fsga2d48vnj31bm052gmd.jpg)

但是SDS因为保存了字符串的free及len属性，所以在进行字符串拼接的时候，可以根据free字段来判断内存空间是否足够，如果不够，那么会自动进行SDS空间扩展，再进行拼接的操作。**所以SDS是安全的，不会存在缓冲区溢出的问题**。

3、对于C字符串，如果在进行字符串拼接的时候，忘记了进行内存重分配的话，将会造成缓冲区溢出的可能；而进行字符串截断的时候，不释放截断部分不再使用的空间，将会造成内存泄漏。但是如果频繁的进行内存重分配，是需要进行系统调用的，是比较耗时的。

对于Redis数据库而言，对字符串的拼接或修改操作是比较频繁的，如果每次操作都进行一次内存重分配，那么明显是不合适的。所以C字符串是不符合Redis数据库的，而SDS为了避免这种缺陷，实现了**空间预分配**及**惰性空间释放**两种分配策略；

* 空间预分配：空间预分配是指在需要进行内存重分配的时候，程序不仅仅会把len属性扩展成记录目标字段需要的长度，同时也会把free属性进行相应的扩展，预先分配空间。free属性的扩展有以下两种方式：

  1、如果修改之后的len属性长度小于1MB，那么给free分配同len属性同样大小的空间；

  2、如果修改之后的len属性长度大于等于1MB，那么给free分配1MB的空间；

  注：SDS的buf数组实际长度为len + free + 1byte。

* 惰性空间释放：惰性空间释放是用于优化字符串收缩的操作：当用SDS的api对字符串进行收缩操作时，不会对未使用的那部分空间直接回收，而是用free属性把这些字节数据记录起来，等待将来使用；

4、因为C字符串是以`\0`结尾的，所以无法保存二进制数据；但是SDS是使用len属性的值而不是`\0`来判断字符串是否结束的，所以SDS是可以保存二进制数据的；

5、SDS是兼容部分C字符串函数的；



### 链表

链表在Redis中用list来表示，而list中存在着以下属性：

* listNode *head：是一个指针，指向表头节点
* listNode *tail：是一个指针，指向表尾节点
* long len：链表中节点的数量，所以获取链表的长度的时间复杂度为O(1)
* dup函数：复制链表节点中所保存的值
* free函数：释放链表节点中所保存的值
* match函数：对比链表节点中所保存的值跟另一个输入的值是否相等

listNode代表的是一个链表节点，属性结构如下：

* listNode *prev：指针，指向前置节点
* listNode *next：指针，指向后置节点
* *value：指针，指向节点的值

**以下截图代表着由list结构跟listNode结构组成的链表**

![image-20180619103950928](https://ws1.sinaimg.cn/large/006tNc79gy1fsgafkx5mzj31460d6wgf.jpg)



Redis链表的特性如下：

> 双端：链表节点存储着prev跟next指针，所以获取某个节点的前后置节点时间复杂度都为O(1)
>
> 无环：表头节点的prev跟表尾节点的next指针都指向NULL，以NULL节点代表链表结束
>
> 存在表头及表尾的指针，及存在len属性，所以获取表头节点、表尾节点、链表长度的时间复杂度都为O(1)
>
> 多态：链表节点用void*指针保存节点的值，并用list结构中的dup、free、match的三个属性为节点值设置类型的特定函数，所以链表上可以存储各种不同类型的值

**注：Redis中的发布订阅、慢查询、监视器等都是通过链表实现的；**

### 字典

字典就是我们常说的键值对存储的数据结构，Redis的底层就是用字典实现的；Redis的字典是使用哈希表实现的。

####哈希表结构

哈希表在Redis中用dictht结构表示，存在着以下属性

* **table：数组指针，指向dictEntry结构，每个dictEntry存储着一个键值对
* long size：记录哈希表的大小
* long sizemask：哈希表的大小掩码，用于计算索引值，总是等于size-1
* long used：已有节点的数量

dictEntry代表的是哈希表节点，对应以下属性

* *key：保存着数据库的键
* v：保存着键值对的值，可以是一个指针、一个uint64_t整数、一个int64_t整数。
* *next：指向另一个哈希表节点的指针

哈希节点示例如下：

![image-20180619104041954](https://ws2.sinaimg.cn/large/006tNc79gy1fsgaggrwd4j31dq0eadi5.jpg)



#### 字典结构

Redis中的字典用dict结构表示，存在着以下属性

* dictType *type：指向一个dictType结构的指针，保存操作特定类型键值对的函数，为不同用途的字典设置不同的类型特定函数
* *privdata：保存需要传给那些特定函数的可选参数
* dictht ht[2]：包含两个哈希表，一般情况下，ht[0]哈希表直接使用，ht[1]哈希表用来进行rehash时使用
* int rehashidx：rehash索引，当进行rehash不在进行时，值为-1

dictType中存在着以下函数：

* hashFunction：计算哈希值的函数
* keyDup：复制键的函数
* valDup：复制值的函数
* keyCompare：比较键的函数
* keyDestructor：销毁键的函数
* valDestructor：销毁值的函数

**以下表示未进行rehash的字典示例：**

![image-20180619104106635](https://ws3.sinaimg.cn/large/006tNc79gy1fsgagx53qij31dk0q6n1a.jpg)



####哈希算法

当要把一个键值对放到字典中去的时候，首先要算出键对应的哈希值和索引值，再根据索引值，将包含新键值对的哈希表节点放到指定的索引上面。

计算方法如下：

```
# 使用字典中设置的计算哈希值的函数，计算键的哈希值
hash = dict->type->hashFunction(key);
# 根据哈希表的sizemask属性和哈希值，计算出索引值
# 根据实际情况，ht[x]可能是ht[0]或者ht[1]
index = hash & dict->ht[x].sizemask;
```

另注：当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用**MurmurHash2**算法来进行键的哈希值的计算；

#### 哈希键冲突

当用哈希算法算出来的键被分配到同一个索引上面时，就造成了哈希值冲突。而当哈希键冲突的时候，Redis采用的是**链地址法**来解决哈希键的冲突。每个哈希表节点都有一个next指针，多个哈希表节点可以用next形成一条单向链表。

注：因为dictEntry节点组成的链表没有指向链尾的指针，为了效率考虑，程序总是将新的哈希表节点添加到链的表头位置（时间复杂度为O(1)）。

#### rehash

当数据越来越多的时候，哈希键冲突将为越发出现，这样会形成一个很长的单向链条，为了让哈希表的负载因子(load_factor)维持在一个合理的范围内，需要对哈希表进行扩展操作，步骤如下：（数据减少进行收缩操作也是一样的）

1. 为哈希表ht[1]分配新的空间，大小取决于要执行的操作（扩展还是收缩）及ht[0]当前包含的键值对数量(ht[0].used)；

  ​	扩展操作：ht[1]的大小为第一个大于等于ht[0].used*2的2的n次方幂；

  ​	收缩操作：ht[1]的大小为第一个大于等于ht[0].used的2的n次方幂；

2. 将保存在ht[0]的所有键值对rehash到ht[1]上。rehash：指重新计算键的哈希值和索引值，将键值对放置到ht[1]哈希表指定的位置上。

3. 当ht[0]的键值对全部迁移到ht[1]上时，释放ht[0]，将ht[1]指向ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。

**另注：哈希表的扩展及收缩条件如下，当满足任一条件时便进行rehash**

* 服务器目前**没有进行**BGSAVE命令或者BGREWRITEAOF命令，且哈希表的负载因子**大于等于1**；
* 服务器目前**正在进行**BGSAVE命令或者BGREWRITEAOF命令，且哈希表的负载因子**大于等于5**；

```
# 哈希表负载因子计算公式
# 负载因子 = 哈希表已保存的数据节点数量 / 哈希表大小
load_factor = ht[0].used / ht[0].size
```

#### 渐进式rehash

在进行rehash的时候，需要把ht[0]的所有键值对rehash到ht[1]中，但是这个动作并不是一次性完成的，而是分多次，渐进式的完成的；原因是当ht[0]中同时保存着上亿条数据时，一次性rehash可能会导致服务器在一段时间内停止工作，这是不被允许的；

所以字典进行rehash的操作是渐进式的，步骤如下：

1. 为ht[1]分配空间，让字典同时持有ht[0]及ht[1]两个哈希表
2. 在字典中维持一个索引计算器rehashidx，并把值初始化为0，表示rehash工作正式开始
3. 在rehash操作期间，每次对新字典的添加、删除、查找、更新操作，程序除了执行指定的操作以外，还会顺带把ht[0]的哈希表在rehashidx索引上的所有键值对rehash到ht[1]上，当rehash工作完成之后，程序将rehashidx属性加1。
4. 随着字典操作的不断执行，最终在某个时间节点上，ht[0]的所有键值对都会被rehahs到ht[1]上，这时将rehashidx的属性设置为-1，表示rehash操作完成。

渐进式rehash的好处在于将rehash键值对所需要的计算工作平摊到没每个字典的添加、删除、查找跟更新操作上，从而避免了集中式rehash带来的庞大计算量。

**另注：在渐进式rehash过程中，字典会同时使用ht[0]和ht[1]表，所以在渐进式rehash进行期间，字典的删除、查找、更新等操作会在两个哈希表中进行。**

### 跳跃表

跳跃表是一种有序的数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。

Redis的跳跃表用zskiplistNode跳跃表节点跟zskiplist跳跃表结构组成，相关属性如下

**zskiplist跳跃表：**

* header：指向跳跃表的表头节点
* tail：指向跳跃表的表尾节点
* level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）
* length：记录跳跃表的长度，也就是跳跃表包含的节点数量（表头节点不计算在内）

**zskiplistNode跳跃表节点：**

* level[]：层。节点中用L1、L2等标识来标记各个层，L1代表第一层，以此类推；一般来说，层的数量越多，访问其他节点的速度就越快。每个层带有两个属性

  * 前进指针：前进指针用于指向表尾方向的其他节点
  * 跨度：用于记录前进指针所指向节点和当前节点的距离

  每次创建一个跳跃表节点的时候，程序都会根据**幂次定律**，随机生成一个1～32之间的值作为level数组的大小，作为该层的高度。

* backward：后退指针。节点中用BW字样标记节点的后退指针，指向该节点的上一个节点。后退指针用于从表尾节点向表头节点遍历时使用。**跟前进指针不同，后退指针只能指向上一个节点，无法跳过多个节点。**

* scope：分值。double浮点型数据，节点中根据该数值进行从大到小的排列。

* obj：成员对象。指向一个字符串对象，字符串对象底层保存着一个SDS。

**跳跃表结构如下**

![image-20180619111544365](https://ws2.sinaimg.cn/large/006tNc79gy1fsgbgxrkk3j319q0hwtcq.jpg)

**跳跃表查找步骤**

1. 从表头节点的最高层开始查找，如果最高层的前进指针不为NULL，那么比较表头节点的scope跟前进指针指向节点的scope，如果找到则返回；未找到，判断目标scope是否在区间内，如果是则从表头节点的下一个层开始查找。如果目标scope比前进指针指向的scope还大，那么从前进指针指向的节点的下一层开始查找。
2. 以步骤1的方式依次查找，如果找到则返回，找不到往下一个层继续找。
3. 如果最终没有找到，返回NULL，否则返回具体的obj对象。

**示例：**

![image-20180619112526673](https://ws3.sinaimg.cn/large/006tNc79gy1fsgbqy3db2j31a8074ab4.jpg)

![image-20180619112538349](https://ws4.sinaimg.cn/large/006tNc79gy1fsgbr5mdh7j31aw09uabn.jpg)

以上两张图展示了查找数据19的过程。



### 整数集合

整数集合在Redis中用intset表示，其属性如下：

* encoding：编码方式
  * INTSET_ENC_INT16：代表contents是一个int16_t类型的数组，数组的每一个项都是一个int16_t类型的整数值(-32768~32767)。`2的15次幂`
  * INTSET_ENC_INT32：代表contents是一个int32_t类型的数组，数组的每一个项都是一个int32_t类型的整数值(-2147483648~2147483647)。`2的31次幂`
  * INTSET_ENC_INT64：代表contents是一个int64_t类型的数组，数组的每一个项都是一个int64_t类型的整数值(-9223372036854775808~9223372036854775807)。`2的63次幂`
* length：集合包含的元素数量，也就是contents数组的长度
* contents[]：保存元素的数组，整数集合的每个元素都是contents数组的一个数组项，每个数组中按值大小从大到小排列，且不含重复值。数组大小为：sizeof(encoding) * length。

#### 升级

升级是指当我们把新的元素往整数集合中放时，但是encoding指定的元素长度不足以支撑新元素的大小，需要对整数集合进行升级，才能将新元素添加到整数集合中。

1. 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
2. 将底层数组现有的所有元素转换到与新元素相同类型的元素类型，并将类型转换后的元素在新空间中放置到正确的位置上，而且在放置元素的过程中，需要维持底层数组的有序性不变。
3. 将新元素添加到底层数组里面。

**示例：**

假设现在有一个整数集合，保存着三个int16_t类型的元素，结构如下

| intset |
| ------ |
| encoding（INTSET_ENC_INT16） |
| length（3） |
| contents --按照公式，contents的大小为16*3 = 48位 |

contents中保存的数据如下：

| 位   | 0～15位 | 16～31位 | 32～47位 |
| ---- | ------- | -------- | -------- |
| 元素 | 1       | 2        | 3        |

现在添加一个新的元素32768，因为int16_t无法容纳32768，所以需要对整数集合进行升级，将encoding从**INTSET_ENC_INT16**升级到**INTSET_ENC_INT32**。这个时候元素大小为4，所以contents的大小为**32*4=128**位。新扩展后的结构如下：

| 位   | 0～15 | 16～31 | 32～47 | 48～127      |
| ---- | ----- | ------ | ------ | ------------ |
| 元素 | 1     | 2      | 3      | 新分配的空间 |

之后将每个位扩展至32位，并把各个元素放置到正确的位置，如下
| 位   | 0～31 | 32～63 | 64～95 | 96～127 |
| ---- | ----- | ------ | ------ | ------- |
| 元素 | 1     | 2      | 3      | 32768   |

这个时候intset的结构调整为

| intset |
| ------ |
| encoding（INTSET_ENC_INT32） |
| length（4） |
| contents --按照公式，contents的大小为32*4 = 128位 |

**注：因为每次往集合中添加元素都有可能导致升级，每次升级都需要将元素进行类型转换，所以向整数集合中添加新元素的时间复杂度为O(N)**



> 升级的好处
>
> 1、提高灵活性：可以随意将int16_t、int32_t、int64_t类型的值添加到整数集合中，不用担心类型错误问题
>
> 2、节约内存：不是统一用int64_t进行数据存储，而是在需要的时候再转换。



#### 降级

整数集合在升级之后不能被重新降级，也就说整数集合从INTSET_ENC_INT16升级到INTSET_ENC_INT32，后续将INTSET_ENC_INT16相关的所有数据都删除了，也不会降级成INTSET_ENC_INT16。



### 压缩列表

压缩列表是为了Redis节约内存而开发的，由一系列特殊编码的连续内存块组成的顺序型数据结构。组成如下：

![image-20180619135624723](https://ws2.sinaimg.cn/large/006tNc79gy1fsgg455bsdj31d803eaas.jpg)

| 属性    | 类型     | 长度  | 用途                                                         |
| ------- | -------- | ----- | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4字节 | 记录整个压缩列表所占用的内存字节数：在对压缩列表进行内存重分配、或者计算zlend的位置时使用 |
| zltail  | uint32_t | 4字节 | 记录压缩列表的表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，列表无需遍历整个压缩列表就可以确定表尾节点的地址 |
| zllen   | uint16_t | 2字节 | 记录整个压缩列表包含的节点数量：当这个属性的值小于UINT16_MAX(65535)时，这个属性的值就是压缩列表所包含的节点数量。当这个属性等于UINT16_MAX(65535)时，压缩节点说包含的节点数量需要遍历整个压缩列表才能算出来 |
| entryX  | 列表节点 | 不定  | 压缩列表保存的各个节点，各个节点的长度由节点保存的内容决定   |
| zlend   | uint8_t  | 1字节 | 特殊字0xFF（十进制255），用于记录压缩列表的末端              |

一个压缩列表可以包含任意多的压缩节点，每个节点可以保存一个字节数组跟一个整数值。字节数组跟整数值的要求如下：

**字节数组可以是以下三种长度的一种**

* 长度小于等于63（2^6 - 1）字节的字节数组；
* 长度小于等于16383（2^14 - 1）字节的字节数组；
* 长度小于等于4294967295（2^32 - 1）字节的字节数组；

**整数值可以是以下六种长度的一种**

* 4位长，介于0～12之间的无符号整数；
* 1字节长的有符号整数；
* 3字节长的有符号整数；
* int16_t类型整数；
* int32_t类型整数；
* int64_t类型整数；

每个压缩节点由以下三个部分组成

* previous_entry_length：上一个节点的长度，以字节为单位；值可能是1字节或者5字节

  * 如果前一个节点的长度小于254字节，那么该属性的长度为1字节：前一节点的长度保存在这一个字节里面。
  * 如果前一节点的长度大于等于254字节，那么该属性的长度为5字节：其中属性的第一个字节被设置为0xFE(十进制值254)，而之后的四个字节则保存前一节点的长度。

  **程序可以通过指针运算，根据当前节点的起始地址来计算出前一节点的起始地址。压缩列表从表尾向表头遍历就是使用该原理实现的。**

* encoding：记录节点的content属性的类型及长度

  * 一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性记录的是字节数组，数组的长度由编码去掉最高位两位之后的其他位记录；
  * 一字节长、值的最高位以11开头的整数编码：这个编码表示节点的content属性记录的是整数值，整数值的类型和长度是由编码去掉最高位两位之后的其他位记录；

  ![image-20180619142520467](https://ws2.sinaimg.cn/large/006tNc79gy1fsggy8za1bj31kw0ufgvy.jpg)

* content：保存属性的值，值可以是字节数组或者整数，由encoding决定；

#### 连锁更新

因为记录previous_entry_length属性的大小是依赖于上一个字节的实际存储长度的，见上述previous_entry_length说明；

假设现在由3个连续的压缩节点s1、s2、s3，这三个节点的长度都介于250～253之间，因此后一个节点只需要一个字节来记录前一个节点的大小。这个时候我们插入一个new节点，节点长度大于等于254字节，那么s1的previous_entry_length属性将由1字节转换成5字节，从而导致s1的字节长度超过254字节，引发后续节点s2、s3的节点长度的扩展更新。

Redis将以上这种在特殊情况下产生的连续多次的空间扩展成为“`连锁更新`”；

连锁更新在最坏的情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配操作的最坏时间复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)；

**注：**

1. 尽管连锁更新的时间复杂度高，但是他出现的几率是比较低的，因为需要恰好有连续的节点空间处于250～253字节之间。
2. 即使出现连锁更新，只要被更新的字节数量不多，对性能并不会造成太严重的影响。

### 快速列表

> 快速列表（quicklist）是在Redis3.2版本加入的新数据结构，是由双端链表及压缩列表组成的

快速列表在Redis中是有quicklist跟quicklistNode节点组成的；

**quicklist的数据结构包含的属性如下**

```
typedef struct quicklist {
    quicklistNode *head;        // 指向quicklist的头部
    quicklistNode *tail;        // 指向quicklist的尾部
    unsigned long count;        // 列表中所有数据项的个数总和
    unsigned int len;           // quicklist节点的个数，即ziplist的个数
    int fill : 16;              // ziplist大小限定，由list-max-ziplist-size给定
    unsigned int compress : 16; // 节点压缩深度设置，由list-compress-depth给定
} quicklist;
```

**quicklistNode数据结构包含的属性如下**

```
typedef struct quicklistNode {
    struct quicklistNode *prev;  // 指向上一个ziplist节点
    struct quicklistNode *next;  // 指向下一个ziplist节点
    unsigned char *zl;           // 数据指针，如果没有被压缩，就指向ziplist结构，反之指向quicklistLZF结构 
    unsigned int sz;             // 表示指向ziplist结构的总长度(内存占用长度)
    unsigned int count : 16;     // 表示ziplist中的数据项个数
    unsigned int encoding : 2;   // 编码方式，1--ziplist，2--quicklistLZF
    unsigned int container : 2;  // 预留字段，存放数据的方式，1--NONE，2--ziplist
    unsigned int recompress : 1; // 解压标记，当查看一个被压缩的数据时，需要暂时解压，标记此参数为1，之后再重新进行压缩
    unsigned int attempted_compress : 1; // 测试相关
    unsigned int extra : 10; // 扩展字段，暂时没用
} quicklistNode;
```

**quicklistLZF数据结构及包含的属性如下**

```
typedef struct quicklistLZF {
    unsigned int sz; // LZF压缩后占用的字节数
    char compressed[]; // 柔性数组，指向数据部分
} quicklistLZF;
```

![image-20180619145219640](https://ws2.sinaimg.cn/large/006tNc79gy1fsghqad5lpj31cm0k6gq4.jpg)



链接：[文章传送门](https://blog.csdn.net/men_wen/article/details/70229375)



## Redis五种不同类型的对象

### 字符串对象

字符串对象的编码可能是`int、embstr、raw`三种；

如果一个字符串对象保存的是整数值，且这个整数值可以用long来表示，那么该字符串的编码会被设置为int，同时把整数值保存在字符串对象的ptr属性中；

如果一个字符串对象保存的是一个字符串值，且这个字符串值的长度小于等于39（Redis3.2版本是44）字节，那么字符串将会用embstr编码保存这个字符串，反之，将用raw保存；

embstr字符串编码是专门用来保存短字符串的一种优化编码方式，同raw编码一样，都使用redisObject跟SDS来表示字符串对象，但是raw会调用两次内存分配函数来分别创建redisObject跟SDS结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，依次包裹redisObject跟SDS结构；

这么做的好处有：

1. embstr编码将创建字符串对象的分配内存次数从raw编码的两次将为一次。
2. 释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数；
3. embstr编码的字符串对象的所有数据保存在同一块连续的内存空间中，所以这种编码的字符串对象比起raw编码的字符串对象能更好的利用缓存带来的优势；

#### 编码的转换

int编码跟embstr编码的字符串对象在满足条件的情况下，会被转换成raw编码的字符串对象；

* 对int编码而言，如果执行了一些命令，使得对象中保存的不再是整数值，那么就会把编码转换成raw编码；
* 对embstr编码而言，因为Redis没有提供任何相应的修改程序（int跟raw有），所以embstr编码的字符串是只读的，如果执行了任何的修改操作，那么就会把embstr编码转换成raw编码；

**各个不同编码的命令执行操作如下**

![image-20180619183734269](https://ws4.sinaimg.cn/large/006tNc79gy1fsgo8m3qx0j31ik0p0nc5.jpg)

![image-20180619183749747](https://ws1.sinaimg.cn/large/006tNc79gy1fsgo8vq3wyj31ia0qagze.jpg)



### 列表对象

列表对象的底层编码实现可能是`ziplist、linkedlist、quicklist`三种；注：新版本（Redis3.2）中列表对象的底层实现是quicklist，这里的记录暂时忽略quicklist；

* 用ziplist编码保存的列表对象，每个压缩列表节点保存一个列表元素。
* 用linkedlist编码保存的列表对象，每个双端链表节点保存着一个字符串对象，**每个字符串对象都保存着一个列表元素**。

#### 编码转换

当列表对象的元素同时满足以下两个条件时，列表对象用ziplist编码：

1. 列表对象保存的所有字符串元素的长度都小于64字节；
2. 列表对象保存的元素数量小于512个；

不满足以上条件的列表对象，将使用linkedlist作为编码；以上的两个条件的值是可以修改的，可通过修改`list-max-ziplist-value`和`list-max-ziplist-entries`实现；

**注：以上讨论在quicklist未出现之前，Redis3.2版本中已经使用quicklist作为底层编码；**

![image-20180619184805375](https://ws1.sinaimg.cn/large/006tNc79gy1fsgojppsx6j31j818q7s5.jpg)



### 哈希对象

哈希对象的底层编码实现为`ziplist、ht`两种；

* ziplist编码的哈希对象使用压缩列表作为底层实现，当有新的键值对要加入到哈希对象时，程序会将保存了键的压缩列表节点推入到压缩列表表尾，然后把保存了值的压缩列表节点推入到压缩列表表尾，因此：
  * 保存了同一键值对的两个节点总是紧挨在一起，键节点在前、值节点在后；
  * 先添加的哈希节点对象中的键值对会被放到列表的表头方向，后添加的会被放到表尾方向；
* ht编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：
  * 字典的每个键都是一个字符串对象，对象中保存着键值对的键；
  * 字典的每个值都是一个字符串对象，对象中保存着键值对的值；

#### 编码转换

当哈希对象同时满足以下两个条件时，哈希对象将使用ziplist作为编码：

1. 哈希对象所保存的键值对的键跟值的长度都小于64字节；
2. 哈希对象所保存的键值对的数量小于512个；

不能满足以上的条件，哈希对象将使用ht作为底层编码；以上条件的数值时可以修改的，可通过修改`hash-max-ziplist-value`和`hash-max-ziplist-entries`实现。

![image-20180619190054721](https://ws4.sinaimg.cn/large/006tNc79gy1fsgowwtb6xj31kw102qn2.jpg)

### 集合对象

集合对象的编码可以是`intset、ht`两种。

* 使用intset作为编码，将使用整数集合作为底层实现。集合对象包含的所有元素都被保存在整数集合中；
* 使用ht作为编码，将使用字典作为底层实现。字典的每一个键都是一个字符串对象，每个字符串对象包含着一个集合元素，而字典的值全部指向NULL；

#### 编码转换

当集合对象可以同时满足以下两个条件时，集合对象将用intset作为编码：

* 集合对象保存的所有元素都是整数值；
* 集合对象保存的所有元素数量不超过512个；

如果无法同时满足两个条件，集合对象将用ht作为编码。上面的第二个条件可以通过修改`set-max-intset-entries`进行修改；

![image-20180619190703064](https://ws2.sinaimg.cn/large/006tNc79gy1fsgp39e832j31je06wmzy.jpg)

![image-20180619190721956](https://ws4.sinaimg.cn/large/006tNc79gy1fsgp3mkn73j31iu0vaka8.jpg)



### 有序集合对象

有序集合对象可以使用`ziplist、skiplist`两种

* 使用ziplist作为编码，将使用压缩列表作为底层实现。每个集合元素用两个紧邻在一起的压缩节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值；其中分值按从小到大排序，分值小的近表头，高的近表尾；

* 使用skiplist作为编码，有序集合将用zset结构作为底层实现。一个zset结构**同时包含一个字典跟一个跳跃表**；

* ```
  typedef struct zset{
      zskiplist *zsl;
      dict *dict;
  } zset;
  ```

  zset结构中的zsl跳跃表按分值从小到大保存所有集合元素，每个跳跃表节点都保存一个集合元素：object保存元素的成员、scope保存着元素的分值；通过跳跃表可以进行范围型操作；

  而dict字典为有序集合创建了一个从成员到分值的映射，字典的每个键值对都保存着一个集合元素：键保存着元素的成员，值保存着元素的分值；因此可以用O(1)的时间负责度来查找指定成员的分值；

  **另：有序集合的每一个元素的成员都是字符串对象，值都是double类型的浮点数。且跳跃表跟字典共享集合元素不会造成内存浪费；**

![image-20180619191957319](https://ws1.sinaimg.cn/large/006tNc79gy1fsgpgogc3hj30v00fsjt2.jpg)

![image-20180619192014587](https://ws4.sinaimg.cn/large/006tNc79gy1fsgpgzqj4yj31js0um7c1.jpg)

**以上截图只是为了方便示例，实际上字符串对象是共享的；**



#### 编码转换

当有序集合同时满足以下两个条件时，将使用ziplist作为编码：

1. 有序集合的元素数量小于128；

2. 有序集合保存的所有元素成员长度都小于64字节；

   不能满足以上条件的，将会使用skiplist作为编码；同时以上的数值也是可修改的，可通过修改`zset-max-ziplist-entries`,`zset-max-ziplist-value`实现；

![image-20180619192350113](https://ws1.sinaimg.cn/large/006tNc79gy1fsgpkq5kyuj31iw0tsqjz.jpg)

![image-20180619192404725](https://ws2.sinaimg.cn/large/006tNc79gy1fsgpkzmhlrj31ic0gy12k.jpg)



## 对象的其他特性

### 类型检查与命令多态

Redis的命令可以分为以下两种

* 所有类型的键都可以被执行操作的，如：DEL、EXPIRE、TYPE、OBJECT等；
* 指定类型的键才可以执行的操作：
  * 字符串：SET、GET、APPEND、STRLEN等；
  * 哈希键：HDEL、HSET、HGET、HLEN等；
  * 列表键：RPUSH、LPOP、LINSERT、LLEN等；
  * 集合键：SADD、SPOP、SINTER、SCARD等；
  * 有序集合键：ZADD、ZCARD、ZRANK、ZSCORE等；

因此对于需要制定类型的键，在执行之前需要进行相应的类型检查，如果执行命令跟类型的键是否是匹配的，如果匹配则执行，否则的话拒绝执行返回错误；

1. 在执行一个类型的命令之前，服务器会先检查输入的数据库键的**值对象**是否为执行命令所需的类型`redisObject.type属性`，如果是的话，执行对应命令；
2. 否则，服务器拒绝执行，返回对应的错误信息；

除此之外，因为每个不同的数据库值对象都可能存在着多种不同的编码`encoding`，所以在执行不同命令的时候，底层调用的实际命令是不一样的，服务器会根据底层不同的encoding选择不同的命令执行，这就是命令多态；

**如执行LLEN命令**

* 如果列表的底层encoding是用ziplist实现的，那么程序将用ziplistlen函数返回列表的长度；
* 如果列表的底层encoding使用linkedlist实现的，那么程序将用listLength函数返回双端链表的长度；

![image-20180620102934984](https://ws2.sinaimg.cn/large/006tNc79gy1fshfr9l0odj319y0ng434.jpg)



> 我们可以把DEL、EXPIRE等任何类型的键都能执行的称为**类型的多态**，因为所有类型都可以响应命令并执行。把类型与LLEN这种指定类型才能执行的称为**编码的多态**，因为Redis会根据对象类型不同的编码执行不同的底层命令



### 内存回收

Redis通过用程序计数器的方式来进行内存的回收，通过在`redisObject`保存**`refCount`**属性来记录被引用的次数，当执行以下操作是，refCount的计数会发生改变；

* 创建一个新对象时，refCount的值会被初始化为1；
* 当对象被一个新程序使用时，refCount+1；
* 当对象不再被一个新程序使用时，refCount-1；
* 当对象的refCount=0时，执行内存回收的动作；

![image-20180620103613060](https://ws3.sinaimg.cn/large/006tNc79gy1fshfy4fr8hj31kc09ugpx.jpg)

### 对象共享

通过refCount除了可以表示该对象的内存是否需要被回收，也记录了该对象是否被共享使用。如键A跟键B都存储着整数值100，这个时候Redis只会创建一个字符串对象，而键A跟键B都指向这个值对象，且refCount值为2；

在Redis中，整数值0～9999会在服务器初始化的时候被创建出来并作为共享对象，所以当使用这些整数值的时候，实际上并不会创建新的对象，而是直接使用共享对象；

> Redis只对整数值进行对象共享的动作，因为验证目标对象跟共享对象是否一致的时间复杂度为O(1)，如果共享的是字符串，需要判断每个字符，那么时间复杂度为O(N)；如果共享对象包含多个值对象，如列表或者哈希，那时间复杂度将为O(N*N)；
>
> 所以Redis只对整数值惊喜对象共享，减少CPU的消耗时间；

### 对象的空转时长

在redisObject中有一个lru属性，该属性记录该对象最后一次被返回的时间，根据当前时间跟该属性的差值，可以算出对象的空转时长。**空转时长在配置不同的过期策略中会被用到**；