# Redis数据库持久化

## 数据库

Redis服务器将把Redis的所有数据库都保存在redisServer结构的db中，db的结构为redisDB。同时在Redis初始化的时候，服务器会根据服务器状态的dbnum属性来决定应该创建几个数据库，默认值为**16**；

```
struct redisServer{
	// 一个数组对象，保存服务器的所有数据库信息
    redisDb *db;
    // 服务器中数据库数量
    int dbnum;
}
```

当我们通过客户端执行`redis-cli`指令时，我们会默认连接上编号为0的数据库。可以通过`select dbNum`的操作来切换数据库；

而在redisClient对象中，则保留着一个redisDb的数据指针，直接指向redisServer.db数组中的其中一个元素，被指向元素即为目标数据库；



redisDb对象的底层是使用字典实现的，Redis是一个键值对K-V数据库，redisDb中的dict字典保存了数据库中的所有键值对，**我们称这个字典为键空间**；

```
typedef struct redisDb{
	// 数据库键空间，保存着数据库的所有键值对
    dict *dict;
} redisDb;
```

* 键空间的键就是数据库的键，统一是字符串对象；
* 键空间的值就是数据库的值，可以是Redis五种对象的任何一种；

在对一个键空间进行读写操作时，除了执行指定的命令，服务器还会对键空间执行额外的动作：

* 在读取一个键之后（读/写操作都要读取键），服务器会根据键是否存在来更改服务器键空间命中(hit)跟不命中(miss)的次数。这两个值可通过`stats info`查看`keyspace_hits`属性跟`keyspace_misses`属性；
* 在读取一个键后，服务器会更改这个键的LRU时间；
* 如果服务器在读取一个键时发现键已经过期，那么服务器会删除这个过期键，再执行相应的操作；
* 如果有客户端正在watch监视某个键，那么服务器会在对被监视的键进行修改后，把这个键标记为脏(dirty)，从而让事务知道这个键已经被修改了；
* 服务器每次修改一个键后，都会对脏(dirty)键计数器加1，**用于触发服务器的持久化跟复制功能**；
* 如果服务器开启了数据库通知功能，那么对键进行修改后，服务器将按配置发送相应的通知。

### 数据库键过期策略

Redis中的数据库键不可能永久的存在于Redis数据库中，除了可以通过del命令删除掉指定的数据库键外，还可以通过设置数据库键的**过期时间**来让数据库键自动失效；

可以通过以下命令来设置数据库键的过期时间：

* EXPIRE <key> <ttl>：将键key的过期时间设置为ttl**秒**后；
* PEXPIRE <key> <ttl>：将键key的过期时间设置为ttl**毫秒**后；
* EXPIREAT <key> <timestamp>：将键key的过期时间设置为timestamp说指定的**秒**的时间戳；
* PEXPIREAT <key> <timestamp>：将键key的过期时间设置为timestamp说指定的**豪秒**的时间戳；

> 在实际执行时，`EXPIRE`会转换成`PEXPIRE`指定，而`PEXPIRE`跟`EXPIREAT`会转换成`PEXPIREAT`命令，所以实际上是以上四个命令的底层都是通过`PEXPIREAT`命令实现的；

同样也可以通过以下命令查数据库键还有多久过期：

* TTL <key> ：返回键key剩余的过期时间，单位为**秒**；
* PTTL <key> ：返回键key剩余的过期时间，单位为**毫秒**；

> 如果数据库键已经过期，那么将会返回**-2**；如果数据库键没有设置过期时间，将会返回**-1**；

在Redis中通过在redisDb结构的expires字典中保存数据库键的所有过期时间，该字典称为过期字典；

* 该字典的键指向键空间中的某个键对象，也就是某个数据库键对象
* 该字典的值存储着一个long long类型的整数，代表键所指向的数据库键对象的过期时间，为一个UNIX时间戳，即`PEXPIREAT`命令实际存储的值；

```
typedef struct redisDb{
    // 过期字典
    dict *expires;
} redisDb;
```

> 如果在设置了一个数据库键的过期时间后，想要把过期时间清除掉，可以通过`PERSIST`命令实现。实现原理为通过传进去数据库键key，找到expires字典，并删除掉匹配上的数据库键；



当我们设置了数据库键的过期时间后，当到了指定的时间，Redis会自动把该数据库键删除，具体有以下实现策略

* 定时删除：在设置了键过期时间的同时，创建一个定时器，在过期时间到来的时候把数据库键删除；

  > 这种对内存最友好，因为只要键一过期，就会立即被服务器删除掉，减少时间延迟，避免在内存中存放已过期的数据。但是因为设置了定时器，所以对CPU是有负载的。如果要大量的过期数据，那么就会设置很多的定时器，CPU的时间都用到了删除过期数据库键上了；
  >
  > 而且当前定时器的实现方式是通过**无序链表**实现的，也就是说找到一个指定的定时器时间复杂度为O(N)，并不能高效的进行处理时间事件；

* 惰性删除：设置了键过期时间后不管，当在使用这些数据库键的时候，检查数据库键是否已经过期，如果已经过期的话，直接删除；

  >这种不需要花费CPU的时间，但对内存最不友好，因为如果数据库键已经过期了，但是一直没有请求返回数据库的过期数据，那么服务器中会一直保留这些数据，也就是说内存中可能保存一堆无用已过期的数据；

* 定期删除：每隔一段时间，程序对数据库进行一次检查，删除里面的过期键；至于删除多少过期键，检查哪些数据库，具体由算法决定；

  > 对比以上的两种，定期删除是两种的折中实现；每隔一段时间执行一次，可以通过减少执行的频率跟次数来减少CPU的占用。而通过定期执行，不会让大量已经过期的数据仍旧存放在服务器内存中；
  > 不过对于执行的频率跟次数需要比较难界定；

Redis中使用**惰性删除**跟**定期删除**两个策略进行过期数据的清楚；Redis默认每100ms执行定期删除时会检查所有数据库，每个数据库检查20个数据库键。并可以记录上次检查执行到哪个数据库，从而继续往下执行；

另注：即使采用惰性删除跟定期删除也有可能会出现问题，假设每次定期删除的随机检查时，过期的数据库键都没被选中，而且近期也没有请求返回这个数据库键，那么该数据库键将会长期存留在内存中，这个时候就要用**内存淘汰机制**来保证内存的大小了；

### 内存淘汰机制

Redis中可以当内存不足的时候，执行以下内存淘汰策略

* noeviction：当内存不足的时候，无法写入新的数据，会报错；
* allkeys-lru：当内存不足的时候，在键空间中，将最近最少使用的相关键移除掉；
* allkeys-random：当内存不足的时候，在键空间中，随机删除某个数据库键；
* volatile-lru：当内存不足的时候，在设置了过期时间的键空间中，将最近最少使用的key移除掉；
* volatile-random：当内存不足的时候，在设置了过期时间的键空间中，随机删除某个数据库键；
* volatile-ttl：当内存不足的时候，在设置了过期时间的键空间中，将更早过期时间的key优先移除掉；

> 如果key没有设置过期时间，那么volatile-lru、volatile-random、volatile-ttl策略将跟noeviction的策略的效果是一样的

### 持久化及主从时对过期键的处理

#### RDB持久化

如果Redis服务器开启了RDB持久化，那么在执行SAVE或者执行BGSAVE命令的时候，如果Redis数据库的部分键已经过期了，那么这部分键不会被写入到RDB文件中。而在服务器启动加载RDB文件时，根据服务器的类型会有区分

* 如果是主服务器，那么在服务器加载完RDB文件后，会对数据库键进行判断是否已经过期，如果已过期，不加载进内存中；
* 如果是从服务器，依旧会加载进内存中；但是因为在进行主从复制的时候，从服务器会把数据清空，再接收主服务器传递过来的RDB文件，所以一般来说也不会有什么影响；

#### AOF持久化

在开启AOF持久化时，如果数据库键已过期但是还没有被惰性删除或者定期删除策略删除时，不会做任何操作；当被某个策略删除掉的时候，会往AOF文件中追加一个删除del命令；

同时在进行AOF重写的时候，Redis也会对数据进行是否过期的检查，如果已过期，那么将不会写进到AOF文件中；

#### 主从复制

当我们在主服务器中读取了一个过期数据时，Redis会在删除指定的数据库键后，往所有的从服务器发一条del命令，代表该数据已经被主服务器删除了；而如果是从服务器读取到了一条已经过期的数据，则不会做删除的动作，而是直接返回数据；也就是说从服务器的过期数据的删除依据，都是来自主服务器的命令，只有主服务器会对过期键进行删除的动作；



## 持久化

Redis是内存数据库，所以数据库存储的数据都会保存在服务器内存中，但是如果不对数据库进行持久化，那么一旦服务器宕机了，那么就会丢失所有的数据；

Redis提供了两种持久化功能：

* RDB持久化：RDB持久化是把数据库的数据快照存储起来，对中间执行过程中的命令不关心；
* AOF持久化：AOF持久化则是会把Redis的执行的每一条相关的命令追加到AOF文件中；

### RDB持久化

RDB持久化会将数据库的快照信息压缩成二进制文件，然后保存到*.rdb文件中，在服务器启动的时候，会加载相关的rdb文件，对数据进行恢复的操作；

#### RDB持久化策略

Redis会通过配置在redis.conf中相关配置来执行RDB持久化的策略

```
# 如果在900秒内数据库的数据库键进行了1次变动操作，那么将把数据库最新的快照信息持久化到磁盘
save 900 1 
# 如果在300秒内数据库的数据库键进行了10次变动操作，那么将把数据库最新的快照信息持久化到磁盘
save 300 10
# 如果在60秒内数据库的数据库键进行了10000次变动操作，那么将把数据库最新的快照信息持久化到磁盘
save 60 10000
```

以上的数据格式将保存在redisServer结构中

```
struct redisServer{
	// 记录了保存条件的数组
    struct saveparam *saveparams;
	// 修改的计数器
	long long dirty;
	// 上一次执行保存的时间
	time_t lastsave;
};
struct saveparam{
	// 配置的秒数
    time_t seconds;
    // 配置的修改数
    int changes;
};
```

> saveParam中的结构就是redis.conf中配置的配置信息，而dirty跟lastsave则是服务器保存的数据，用来计算是否到了执行时间且距离上一次执行rdb操作进行了多少次修改操作；

除了等Redis自动帮我们把数据库的快照信息持久化到磁盘，我们也可以手动将数据持久化到磁盘

* SAVE：该命令会阻塞Redis主服务进程，知道RDB文件创建成功，期间Redis服务器无法提供服务；

* BGSAVE：该命令会fork一个子进程进行RDB文件的创建操作，期间Redis服务器可以正常提供服务；

>在BGSAVE命令执行期间，无法执行SAVE跟BGSAVE操作，Redis无法支持一个父进程跟一个子进程或者说两个子进程同时执行rdbSave操作，防止产生竞争；
>
>同时BGSAVE跟BGREWRITEAOF命令也不能同时执行，如果BGSAVE先执行，那么BGREWRITEAOF命令会延迟到BGSAVE执行完毕后再执行，而如果BGREWRITEAOF命令正在执行，那么BGSAVE命令会被拒绝掉；BGSAVE跟BGREWRITEAOF命令无法同时执行不是因为担心存在竞争，而是防止两个子进程同时进行写磁盘的操作；

不同于持久化到磁盘可以手动执行命令，如果要将持久化的rdb文件恢复加载到服务器中，是没有命令支持的，也就是说在服务器启动的时候就已经执行加载rdb文件的操作了，**而且在加载rdb文件期间，数据库是无法提供服务的，一直处于阻塞状态**；

#### RDB文件格式

一个RDB文件包含以下结构

* REDIS：常量，代表这是一个RDB文件；5字节
* db_version：版本号，记录当前Redis的版本号，存储的值为一个整数的字符串；4字节
* databases：包含0个或者任意多个数据库，以及数据库中的相关键值对，可为空
* EOF：常量，RDB文件正文的结束标识；1字节
* check_sum：验签字符串，无符号整数，根据前面四个属性计算得出，验证RDB是否合法没出错；8字节

databases中保存着多个数据库，如果数据库不为空，结构如下

* SELECTDB：常量，代表存在相关数据库，当读入程序读取到这个值时，后面紧接着数据库的编号；1字节
* db_number：数据库号码，根据号码的大小可能为1字节、2字节、5字节
* key_value_pairs：保存数据库的所有键值对数据，如果数据库键存在过期时间，那么过期时间也会跟键值对保存在一起

key_value_pairs结构如下

* EXPIRETIME_MS：如果数据库键存在过期时间，那么存在该常量，后面紧接着过期时间，过期时间单位为毫米
* ms：数据库键对应的过期时间
* TYPE：常量，代表数据库值的数据类型，可以是以下类型
  * REDIS_RDB_TYPE_STRING
  * REDIS_RDB_TYPE_LIST
  * REDIS_RDB_TYPE_SET
  * REDIS_RDB_TYPE_HASH
  * REDIS_RDB_TYPE_ZSET
  * REDIS_RDB_TYPE_LIST_ZIPLIST
  * REDIS_RDB_TYPE_SET_INTSET
  * REDIS_RDB_TYPE_ZSET_ZIPLIST
  * REDIS_RDB_TYPE_HASH_ZIPLIST
* key：数据库键，总是一个字符串对象
* value：数据库值，跟据TYPE的值的不同结构不同
  1. REDIS_RDB_TYPE_STRING

     如果对象的编码为REDIS_ENCODING_INT，代表保存的是长度不超过32的整数，结构为

     * ENCODING：保存对应的编码，可以为`REDIS_RDB_ENC_INT8`、`REDIS_RDB_ENC_INT16`、`REDIS_RDB_ENC_INT32`
     * integer：具体的整数值

     如果对象的编码为REDIS_ENCODING_RAW，且字节长度不超过20字节，那么不压缩原样保存，结构为

     * len：字符串字节长度
     * string：实际存储的字符串

     如果字节超过20字节，那么会被压缩，结构为

     * REDIS_RDB_ENC_LZF：常量，代表字符串被压缩，服务器会根据后面的数据用LZF算法解压缩
     * compressed_len：被压缩之后的长度
     * origin_len：字符串原来的长度
     * compressed_string：被压缩后的字符串

  2. REDIS_RDB_TYPE_LIST

     列表对象，结构如下

     * list_length：列表的长度
     * itemN：保存的列表项的值，存储的都是字符串对象

  3. REDIS_RDB_TYPE_SET

     集合对象，结构如下

     * set_size：集合的大小
     * elemN：集合元素，存储的都是字符串对象

  4. REDIS_RDB_TYPE_HASH

     哈希对象，结构如下：

     * hash_size：哈希表的大小
     * key_value_pairN：键值对对象，键跟值存储的都是字符串对象

  5. REDIS_RDB_TYPE_ZSET

     有序集合对象，结构如下：

     * sorted_set_size：有序集合对象大小
     * elementN：集合元素，存储的分值跟元素值，分值为double浮点数，元素值为字符串对象

  6. REDIS_RDB_TYPE_SET_INTSET

     整数集合对象，直接保存的是对应的整数集合，Redis在保存成RDB文件时，会把整数转换成字符串，在加载RDB文件时，会把字符串转换成整数值

  7. REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_ZSET_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST

     压缩列表对象，存储方式为先把压缩列表转换成字符串对象，在保存到RDB文件中，加载的时候把字符串对象转换成相应的压缩列表对象，根据TYPE类型进行转换；

### AOF持久化

AOF持久化可以分为命令追加、文件写入、文件同步三个步骤；

* 命令追加：当服务器开启AOF持久化之后（通过配置`appendonly yes`开启），当服务器完成一个写操作的时候，会以**协议格式**将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾；

  ```
  struct redisServer{
      // AOF缓冲区
      sds aof_buf;
  };
  ```

* 文件写入：当服务器把命令写入到aof_buf缓冲区之后，紧接着的动作就是要将aof_buf缓冲区的数据写入到AOF文件中，也就是持久化到磁盘上；

* 文件同步：因为写入到磁盘是存在磁盘的写缓冲区的，被写入的命令是需要在磁盘的写缓冲区待一会，等一定时间间隔才会同步到磁盘中去的。而Redis可以通过配置`sppendsync`来指定三种策略，决定何时进行同步，同步操作通过系统提供的`fsync`和`fdatasync`两个同步函数去操作

  * always：代表每执行一条命令，就会将命令同步到磁盘中去。这样配置可以避免数据永远不丢失，但是对服务器的负载比较大，因为Redis本来就是写特别频繁的操作，会导致效率特别慢；
  * everysec：代表每一秒钟执行一次同步动作。配置成这个选项，是比较折中的，如果服务器宕机只是会丢失一秒钟的数据而已，也不会给服务器造成比较大的负载；
  * no：代表服务器只负责把命令写入到磁盘的写缓冲区，至于写缓冲区什么时候写入到磁盘中去，由操作系统去决定。（默认是30秒执行一次）丢失数据的风险太大；

同样在服务器启动的时候，如果开启了AOF持久化，那么服务器会读取AOF文件中保存的写命令，还原服务器的数据，但是因为Redis的写命令只能在客户端上下文中执行，所以Redis需要**创建一个不带连接的伪客户端**。

> 不带连接是因为Redis命令不是来源于网络，而是来源于AOF文件；而RDB不需要创建客户端是因为RDB执行的是快照结果，不是Redis命令；

#### AOF重写

因为AOF持久化保存的是每次执行的写命令操作，当我们对同一个数据库键执行了N次命令的时候，AOF文件中将会把这N次命令都保存下来。可想而知，当数据库键越来越多的时候，AOF文件会变得越来越膨胀，所以Redis提供了AOF重写的机制；

AOF重写是指Redis会通过读取服务器当前数据库的状态，对最新的数据库键的数据保存成一条写命令，然后写入到一个新的AOF文件中，并将生成的新的AOF文件替换旧的AOF文件。

> 在实际中，重写程序为了避免客户端输入缓冲区溢出，在对列表、集合、哈希、有序集合对象进行重写的时候，会检查数据库键对应的元素是不是超过了`REDIS_AOF_REWRITE_ITEMS_PER_CMD`常量的值，如果超过了，那么也会拆成多条命令进行写入；`REDIS_AOF_REWRITE_ITEMS_PER_CMD`的值默认为**64**；

跟RDB一样，Redis也是通过开启后台进程的方式来进行AOF重写，这样子进程在进行AOF重写的时候，父进程可以不用阻塞继续响应，但是在子进程进行AOF重写期间，主进程还有可能继续执行其他的写命令，导致服务器当前的数据库状态跟AOF文件不一致。为了解决这个问题，Redis引入了AOF重写缓冲区，在子进程进行AOF重写期间，主进程接收到新的请求后，会进行以下步骤：

* 执行客户端发来的命令
* 将执行后的写命令追加到AOF缓冲区
* 将执行后的写命令追加到AOF重写缓冲区

而当子进程完成AOF重写后，会向父进程发送一个信号，父进程接收到信号后，会执行以下工作：

* 将AOF重写缓冲区的所有内容写入到新的AOF文件中，这时新的AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。
* 对新的AOF文件进行改名，原子的覆盖现有的AOF文件。

在进行以上操作时，主进程会被阻塞。